<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="text.css" />
</head>
<body>
  <header class="bar">
    <a class="back" href="index.html">← Back</a>
  </header>

  <main class="page">
     <p class="puzzle">
     In the twilight times of dusk and dawn, he would prostrate himself before the stone figure, perhaps imagining his unreal son carrying out identical rites in other circular ruins downstream; at night he no longer dreamed, or dreamed as any man does. His perceptions of the sounds and forms of the universe became somewhat pallid: his absent son was being nourished by these diminution of his soul. The purpose of his life had been fulfilled; the man remained in a kind of ecstasy. After a certain time, which some chronicles prefer to compute in years and others in decades, two oarsmen awoke him at midnight; he could not see their faces, but they spoke to him of a charmed man in a temple of the North, capable of walking on fire without burning himself. The wizard suddenly remembered the words of the god. He remembered that of all the creatures that people the earth, Fire was the only one who knew his son to be a phantom. This memory, which at first calmed him, ended by tormenting him. He feared lest his son should meditate on this abnormal privilege and by some means find out he was a mere simulacrum. Not to be a man, to be a projection of another man's dreams--what an incomparable humiliation, what madness! Any father is interested in the sons he has procreated (or permitted) out of the mere confusion of happiness; it was natural that the wizard should fear for the future of that son whom he had thought out entrail by entrail, feature by feature, in a thousand and one secret nights.
 </P>
     <p class="puzzle"> 
     His misgivings ended abruptly, but not without certain forewarnings. First (after a long drought) a remote cloud, as light as a bird, appeared on a hill; then, toward the South, the sky took on the rose color of leopard's gums; then came clouds of smoke which rusted the metal of the nights; afterwards came the panic-stricken flight of wild animals. For what had happened many centuries before was repeating itself. The ruins of the sanctuary of the god of Fire was destroyed by fire. In a dawn without birds, the wizard saw the concentric fire licking the walls. For a moment, he thought of taking refuge in the water, but then he understood that death was coming to crown his old age and absolve him from his labors. He walked toward the sheets of flame. They did not bite his flesh, they caressed him and flooded him without heat or combustion. With relief, with humiliation, with terror, he understood that he also was an illusion, that someone else was dreaming him.
     </p>
    </main>
</body>
</html>
<!-- JS 放在 body 最底部 -->
  <script>
    /**
     * 把<p class="puzzle">里的纯文本切成“碎片span”
     * 你可以调 chunkSize 来控制每片的长度（越小越碎，越像拼图）
     */
    const chunkSize = 26; // 每片大概多少字符（建议 18-32）

    function splitIntoChunks(text, size) {
      const clean = text.replace(/\s+/g, ' ').trim();
      const chunks = [];
      let i = 0;

      while (i < clean.length) {
        // 尽量在空格处断开，不要硬切断单词
        let end = Math.min(i + size, clean.length);
        if (end < clean.length) {
          const lastSpace = clean.lastIndexOf(' ', end);
          if (lastSpace > i + 8) end = lastSpace; // 8 是防止切得太短
        }
        chunks.push(clean.slice(i, end));
        i = end + 1;
      }
      return chunks;
    }

    function randomFromSides() {
      // 0上 1右 2下 3左
      const side = Math.floor(Math.random() * 4);
      const dist = 140 + Math.random() * 220;
      let dx = 0, dy = 0;

      if (side === 0) { dy = -dist; dx = (Math.random() - 0.5) * dist; }
      if (side === 1) { dx =  dist; dy = (Math.random() - 0.5) * dist; }
      if (side === 2) { dy =  dist; dx = (Math.random() - 0.5) * dist; }
      if (side === 3) { dx = -dist; dy = (Math.random() - 0.5) * dist; }

      return { dx, dy };
    }

    function buildPuzzleParagraph(p) {
      const original = p.textContent;
      const parts = splitIntoChunks(original, chunkSize);

      p.textContent = ''; // 清空
      p.classList.add('puzzle-ready');

      parts.forEach((part, i) => {
        const span = document.createElement('span');
        span.className = 'piece';
        span.textContent = part + ' '; // 保留空格

        const { dx, dy } = randomFromSides();
        const rot = (Math.random() - 0.5) * 18; // -9deg ~ 9deg
        const delay = i * 55 + Math.random() * 60; // 拼图节奏

        span.style.setProperty('--dx', dx.toFixed(0) + 'px');
        span.style.setProperty('--dy', dy.toFixed(0) + 'px');
        span.style.setProperty('--rot', rot.toFixed(1) + 'deg');
        span.style.setProperty('--delay', delay.toFixed(0) + 'ms');

        p.appendChild(span);
      });
    }

    // 1) 先把所有 puzzle 段落构造成碎片
    const puzzles = document.querySelectorAll('p.puzzle');
    puzzles.forEach(buildPuzzleParagraph);

    // 2) 滚动到时触发一次拼合
    const io = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('is-visible');
          io.unobserve(entry.target);
        }
      });
    }, { threshold: 0.25 });

    puzzles.forEach(p => io.observe(p));
  </script>

</body>
</html>
