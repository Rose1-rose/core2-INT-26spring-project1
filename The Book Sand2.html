<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="text.css" />
</head>

<body>
  <header class="bar">
    <a class="back" href="index.html">← Back</a>
  </header>

  <main class="page">
    <p class="puzzle">
      The line is made up of an infinite number of points; the plane of an infinite number of lines;
      the volume of an infinite number of planes; the hypervolume of an infinite number of volumes...
      No, unquestionably this is not — more geometrico — the best way of beginning my story. To claim
      that it is true is nowadays the convention of every made-up story. Mine, however, is true.
    </p>
  </main>

  <!-- JS 放在 body 最底部 -->
  <script>
    const chunkSize = 26; // 每片大概多少字符（建议 18-32）

    function splitIntoChunks(text, size) {
      const clean = text.replace(/\s+/g, ' ').trim();
      const chunks = [];
      let i = 0;

      while (i < clean.length) {
        let end = Math.min(i + size, clean.length);
        if (end < clean.length) {
          const lastSpace = clean.lastIndexOf(' ', end);
          if (lastSpace > i + 8) end = lastSpace;
        }
        chunks.push(clean.slice(i, end));
        i = end + 1;
      }
      return chunks;
    }

    function randomFromSides() {
      const side = Math.floor(Math.random() * 4);
      const dist = 140 + Math.random() * 220;
      let dx = 0, dy = 0;

      if (side === 0) { dy = -dist; dx = (Math.random() - 0.5) * dist; }
      if (side === 1) { dx =  dist; dy = (Math.random() - 0.5) * dist; }
      if (side === 2) { dy =  dist; dx = (Math.random() - 0.5) * dist; }
      if (side === 3) { dx = -dist; dy = (Math.random() - 0.5) * dist; }

      return { dx, dy };
    }

    function buildPuzzleParagraph(p) {
      const original = p.textContent;
      const parts = splitIntoChunks(original, chunkSize);

      p.textContent = '';
      p.classList.add('puzzle-ready');

      parts.forEach((part, i) => {
        const span = document.createElement('span');
        span.className = 'piece';
        span.textContent = part + ' ';

        const { dx, dy } = randomFromSides();
        const rot = (Math.random() - 0.5) * 18;
        const delay = i * 55 + Math.random() * 60;

        span.style.setProperty('--dx', dx.toFixed(0) + 'px');
        span.style.setProperty('--dy', dy.toFixed(0) + 'px');
        span.style.setProperty('--rot', rot.toFixed(1) + 'deg');
        span.style.setProperty('--delay', delay.toFixed(0) + 'ms');

        p.appendChild(span);
      });
    }

    const puzzles = document.querySelectorAll('p.puzzle');
    puzzles.forEach(buildPuzzleParagraph);

    const io = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('is-visible');
          io.unobserve(entry.target);
        }
      });
    }, { threshold: 0.25 });

    puzzles.forEach(p => io.observe(p));
  </script>
</body>
</html>
